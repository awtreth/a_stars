#!/usr/bin/env python

import rospy
from std_msgs.msg import String
from geometry_msgs.msg import Twist
from nav_msgs.msg import Odometry
from kobuki_msgs.msg import BumperEvent
import tf
import numpy
import math 

base = .23

#This function consumes linear and angular velocities
#and creates a Twist message.  This message is then published.
def publishTwist(lin_vel, ang_vel):
    global pub

    twist_msg = Twist();		#Create Twist Message

    twist_msg.linear.x = lin_vel	#Populate message with data
    twist_msg.angular.z = ang_vel
    pub.publish(twist_msg)		#Send Message
 
#This function accepts two wheel velocities and a time interval.
def spinWheels(u1, u2, time):
    global pub
    

    lin_vel = (u1+u2)/2			#Determines the linear velocity of base based on the wheels
    ang_vel = (u1-u2)/base		#Determines the angular velocity of base on the wheels.

    twist_msg = Twist();			#Creates two messages: 
    stop_msg = Twist();

    twist_msg.linear.x = lin_vel		#Populate messages with data.
    twist_msg.angular.z = ang_vel
    stop_msg.linear.x = 0
    stop_msg.angular.z = 0
    
    #While the specified amount of time has not elapsed, send Twist messages.
    now = rospy.Time.now().secs
    while (rospy.Time.now().secs - now <= time and not rospy.is_shutdown()):
        pub.publish(twist_msg)
    pub.publish(stop_msg)
    

#This function accepts a speed and a distance for the robot to move in a straight line
def driveStraight(speed, distance):
    global odom_list
    global pose 	

    x0 = pose.pose.position.x	#Set origin
    y0 = pose.pose.position.y

    #Loop until the distance between the attached frame and the origin is equal to the
    #distance specifyed 
    done = False
    while (not done and not rospy.is_shutdown()):
        x1 = pose.pose.position.x
        y1 = pose.pose.position.y
        d = math.sqrt(math.pow(x1-x0, 2) + math.pow(y1-y0, 2))	#Distance formula
        if (d >= distance):
            done = True
            publishTwist(0, 0)
        else:
            publishTwist(speed, 0)

    
#Accepts an angle and makes the robot rotate around it.
def rotate(angle):
    global odom_list
    global pose

    #This node was created using Coordinate system transforms and numpy arrays.
    #The goal is measured in the turtlebot's frame, transformed to the odom.frame 
    transformer = tf.TransformerROS()	
    rotation = numpy.array([[math.cos(angle), -math.sin(angle), 0],	#Create goal rotation
                            [math.sin(angle), math.cos(angle), 0],
                            [0,          0,          1]])

    #Get transforms for frames
    odom_list.waitForTransform('odom', 'base_footprint', rospy.Time(0), rospy.Duration(4.0))
    (trans, rot) = odom_list.lookupTransform('odom', 'base_footprint', rospy.Time(0))
    T_o_t = transformer.fromTranslationRotation(trans, rot)
    R_o_t = T_o_t[0:3,0:3]

    #Setup goal matrix
    goal_rot = numpy.dot(rotation, R_o_t)
    goal_o = numpy.array([[goal_rot[0,0], goal_rot[0,1], goal_rot[0,2], T_o_t[0,3]],
                    [goal_rot[1,0], goal_rot[1,1], goal_rot[1,2], T_o_t[1,3]],
                    [goal_rot[2,0], goal_rot[2,1], goal_rot[2,2], T_o_t[2,3]],
                    [0,             0,             0,             1]])

    #Continues creating and matching coordinate transforms.
    done = False
    while (not done and not rospy.is_shutdown()):
        (trans, rot) = odom_list.lookupTransform('odom', 'base_footprint', rospy.Time(0))
        state = transformer.fromTranslationRotation(trans, rot)
        within_tolerance = abs((state - goal_o)) < .275
        if ( within_tolerance.all() ):
            spinWheels(0,0,0)
            done = True
        else:
            if (angle > 0):
                spinWheels(.1,-.1,.1)
            else:
                spinWheels(-.1,.1,.1)


#This function works the same as rotate how ever it does not publish linear velocities.
def driveArc(radius, speed, angle):
    global odom_list

    w = speed / radius
    v1 = w * (radius + .5*.352)
    v2 = w * (radius - .5*.352)

############################# The rest of this function will be at least as long as rotate



#This function sequentially calls methods to perform a trajectory.
def executeTrajectory():
        print("execute")
	driveStraight(.2, 0.6)	#drive forward 60cm or .6m
	rotate(-1.57)		#turn right 90 deg or -1.5708 rad
	driveStraight(.2, 0.45)	#drive forward 45cm or .45m
	rotate(2.36)		#turn left 135 deg or 2.35619 rad
        driveStraight(0, 0)
	rospy.is_shutdown()
	print "done executing"

        

#Odometry Callback function.
def readOdom(msg):
    global pose
    global odom_tf

    pose = msg.pose
    geo_quat = pose.pose.orientation
  
    odom_tf.sendTransform((pose.pose.position.x, pose.pose.position.y, 0),
        (pose.pose.orientation.x, pose.pose.orientation.y,pose.pose.orientation.z,pose.pose.orientation.w),rospy.Time.now(),"base_footprint","odom")


#Bumper Event Callback function
def readBumper(msg):
    global bumperState
	
    if(msg.state == 1):
	bumperState = 1


#The timer can be used when for saving data to csv files for analysis.
def timerCallback(event):
 
    #with open("/home/joest/trajectory_data.csv", "a") as data_file:
        #data_file.write(str(x) + "," + str(y) + "," + str(theta) + "\n")
	pass

#Main handler of the project
def run():
    global pub
    global pose
    global odom_tf
    global odom_list
    global bumperState

    
    rospy.init_node('lab2')
    pub = rospy.Publisher('/cmd_vel_mux/input/teleop', Twist,queue_size=1)
    sub = rospy.Subscriber('/odom', Odometry, readOdom, queue_size=1)
    bumper_sub = rospy.Subscriber('/mobile_base/events/bumper', BumperEvent, readBumper)
    odom_list = tf.TransformListener()
    odom_tf = tf.TransformBroadcaster()
    odom_tf.sendTransform((0, 0, 0),(0, 0, 0, 1),rospy.Time.now(),"base_footprint","odom")
    sleeper = rospy.Duration(3)
    rospy.sleep(sleeper)
    rospy.Timer(rospy.Duration(.1), timerCallback)

    while not rospy.is_shutdown():
        print("starting")
        executeTrajectory()
        #spinWheels(0.125, .25, 2)
        #driveStraight(.1,.1)
	#rotate(1.5)
        print("complete")
        rospy.loginfo("Complete")
        #rospy.spin() 
        rospy.is_shutdown()

if __name__ == '__main__':
    try:
        run()
    except rospy.ROSInterruptException:
        pass
